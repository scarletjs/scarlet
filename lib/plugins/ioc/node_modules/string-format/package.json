{
  "name": "string-format",
  "version": "0.2.1",
  "description": "Adds a `format` method to `String.prototype`. Inspired by Python's `str.format()`.",
  "author": {
    "name": "David Chambers",
    "email": "dc@hashify.me"
  },
  "keywords": [
    "string",
    "formatting",
    "language",
    "util"
  ],
  "main": "./lib/string-format",
  "homepage": "https://github.com/davidchambers/string-format",
  "bugs": {
    "url": "https://github.com/davidchambers/string-format/issues"
  },
  "licenses": [
    {
      "type": "WTFPL",
      "url": "https://raw.github.com/davidchambers/string-format/master/LICENSE"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/davidchambers/string-format.git"
  },
  "devDependencies": {
    "coffee-script": "1.4.x",
    "mocha": "1.7.x",
    "should": "1.2.x"
  },
  "readme": "# String::format\n\nString::format is a small JavaScript utility which adds a `format` method\nto strings. It's inspired by and modelled on Python's [`str.format()`][1].\n\nWhen `format` is invoked on a string, placeholders within the string are\nreplaced with values determined by the arguments provided. A placeholder\nis a sequence of characters beginning with `{` and ending with `}`.\n\n### string.format(value1, value2, ..., valueN)\n\nPlaceholders may contain numbers which refer to positional arguments:\n\n```coffeescript\n\"{0}, you have {1} unread message{2}\".format(\"Holly\", 2, \"s\")\n# \"Holly, you have 2 unread messages\"\n```\n\nUnmatched placeholders produce no output:\n\n```coffeescript\n\"{0}, you have {1} unread message{2}\".format(\"Steve\", 1)\n# \"Steve, you have 1 unread message\"\n```\n\nA format string may reference a positional argument multiple times:\n\n```coffeescript\n\"{0} x {0} x {0} = {1}\".format(3, 3*3*3)\n# \"3 x 3 x 3 = 27\"\n```\n\nPositional arguments may be referenced implicitly:\n\n```coffeescript\n\"{}, you have {} unread message{}\".format(\"Steve\", 1)\n# \"Steve, you have 1 unread message\"\n```\n\nA format string must not contain both implicit and explicit references:\n\n```coffeescript\n\"My name is {} {}. Do you like the name {0}?\".format(\"Lemony\", \"Snicket\")\n# ERROR: cannot switch from implicit to explicit numbering\n```\n\n`{{` and `}}` in format strings produce `{` and `}`:\n\n```coffeescript\n\"{{}} creates an empty {} in {}\".format(\"dictionary\", \"Python\")\n# \"{} creates an empty dictionary in Python\"\n```\n\nDot notation may be used to reference object properties:\n\n```coffeescript\nbobby = first_name: \"Bobby\", last_name: \"Fischer\"\ngarry = first_name: \"Garry\", last_name: \"Kasparov\"\n\n\"{0.first_name} {0.last_name} vs. {1.first_name} {1.last_name}\".format(bobby, garry)\n# \"Bobby Fischer vs. Garry Kasparov\"\n```\n\nWhen referencing the first positional argument, `0.` may be omitted:\n\n```coffeescript\nrepo = owner: \"pypy\", slug: \"pypy\", followers: [...]\n\n\"{owner}/{slug} has {followers.length} followers\".format(repo)\n# \"pypy/pypy has 516 followers\"\n```\n\nIf the referenced property is a method, it is invoked and the result is used\nas the replacement string:\n\n```coffeescript\nme = name: \"David\", dob: new Date \"26 Apr 1984\"\n\n\"{name} was born in {dob.getFullYear}\".format(me)\n# \"David was born in 1984\"\n\nsheldon = quip: -> \"Bazinga!\"\n\n\"I've always wanted to go to a goth club. {quip.toUpperCase}\".format(sheldon)\n# \"I've always wanted to go to a goth club. BAZINGA!\"\n```\n\n### String.prototype.format.transformers\n\n“Transformers” can be attached to `String.prototype.format.transformers`:\n\n```coffeescript\nString::format.transformers.upper = -> @toUpperCase()\n\n\"Batman's preferred onomatopoeia: {0!upper}\".format(\"pow!\")\n# \"Batman's preferred onomatopoeia: POW!\"\n```\n\nWithin a transformer, `this` is the string returned by the referenced object's\n`toString` method, so transformers may be used in conjunction with non-string\nobjects:\n\n```coffeescript\npeter_parker =\n  first_name: \"Peter\"\n  last_name: \"Parker\"\n  toString: -> @first_name + \" \" + @last_name\n\n\"NAME: {!upper}\".format(peter_parker)\n# \"NAME: PETER PARKER\"\n```\n\nA transformer could sanitizing untrusted input:\n\n```coffeescript\nString::format.transformers.escape = ->\n  @replace /[&<>\"'`]/g, (chr) -> \"&#\" + chr.charCodeAt(0) + \";\"\n\n\"<p class=status>{!escape}</p>\".format(\"I <3 EICH\")\n# \"<p class=status>I &#60;3 EICH</p>\"\n```\n\nOr pluralize nouns, perhaps:\n\n```coffeescript\nString::format.transformers.s = -> \"s\" unless +this is 1\n\n\"{0}, you have {1} unread message{1!s}\".format(\"Holly\", 2)\n# \"Holly, you have 2 unread messages\"\n\n\"{0}, you have {1} unread message{1!s}\".format(\"Steve\", 1)\n# \"Steve, you have 1 unread message\"\n```\n\nString::format does not currently define any transformers.\n\n### string.format()\n\nIf a format string is used in multiple places, one could assign it to\na variable to avoid repetition. The idiomatic alternative is to invoke\n`String::format` with no arguments, which produces a reusable function:\n\n```coffeescript\ngreet = \"{0}, you have {1} unread message{1!s}\".format()\n\ngreet(\"Holly\", 2)\n# \"Holly, you have 2 unread messages\"\n\ngreet(\"Steve\", 1)\n# \"Steve, you have 1 unread message\"\n```\n\n### Running the test suite\n\n    make setup\n    make test\n\n\n[1]: http://docs.python.org/library/stdtypes.html#str.format\n",
  "readmeFilename": "README.md",
  "_id": "string-format@0.2.1",
  "_from": "string-format@0.2.x"
}
