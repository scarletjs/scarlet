{
  "name": "dryice",
  "description": "A CommonJS/RequireJS packaging tool for browser scripts",
  "keywords": [
    "build",
    "commonjs",
    "requirejs"
  ],
  "version": "0.4.10",
  "homepage": "https://github.com/joewalker/dryice",
  "author": {
    "name": "Joe Walker",
    "email": "joe@getahead.org"
  },
  "contributors": [],
  "repository": {
    "type": "git",
    "url": "http://github.com/mozilla/dryice.git"
  },
  "bugs": {
    "url": "http://github.com/mozilla/dryice/issues"
  },
  "directories": {
    "lib": "./lib"
  },
  "main": "./lib/dryice/index.js",
  "engines": {
    "node": ">=0.6.0"
  },
  "licenses": [
    {
      "type": "Apache-2.0",
      "url": "http://www.apache.org/licenses/LICENSE-2.0"
    }
  ],
  "dependencies": {
    "uglify-js": "~1.3.4"
  },
  "readme": "DryIce\n======\n\nDryIce is a CommonJS/RequireJS packaging tool for browser scripts.\n\nIt is basically just a copy function. It takes input from a set of input files,\nwhich can be specified in various ways, optionally filters them and outputs them\nto something else.\n\nDryIce is licensed under the Apache License version 2\n\n\nWhy?\n----\n\nRequireJS has a build tool which is nice and works well, but it requires Rhino\nand therefore Java. With DryIce, your whole build process can be in JavaScript.\n\nDryIce produces a single file output that can include binary files (by base64\nencoding them)\n\n\nHow to install DryIce\n---------------------\n\n    sudo npm install dryice\n\n\nHow does it work?\n-----------------\n\nTo copy a single file:\n\n    copy({\n      source: 'foo.txt',\n      dest: 'bar.txt'\n    });\n\nTo cat a bunch of files together:\n\n    copy({\n      source: [ 'file1.js', 'file2.js' ],\n      dest: 'output.js'\n    });\n\nTo cat together all the files in a directory:\n\n    copy({\n      source: { root:'src' },\n      dest: 'built.js'\n    });\n\nAs above, but only use the JavaScript files:\n\n    copy({\n      source: { root:'src', include:/.*\\.js$/ },\n      dest: 'built.js'\n    });\n\nAs above, but exclude tests:\n\n    copy({\n      source: { root:'src', include:/.*\\.js$/: exclude:/test/ },\n      dest: 'built.js'\n    });\n\nIf your set of files is very custom:\n\n    copy({\n      source: function() {\n        var files = [ 'file1.js' ];\n        if (baz) files.push('file2.js');\n        return files;\n      },\n      dest: 'built.js'\n    });\n\nWe can filter the files on the way:\n\n    copy({\n      source: /src/.*\\.js$/,\n      filter: copy.filter.uglifyjs,\n      dest: 'built.js'\n    });\n\nThis includes running multiple custom filters:\n\n    copy({\n      source: 'src/index.html',\n      filter: [\n        function(data) {\n          return data.replace(/Sun/, 'Oracle');\n        },\n        htmlCompressor\n      ],\n      dest: 'war/index.html'\n    });\n\nResults can be stored and then used/reused:\n\n    var sources = copy.createDataObject();\n    copy({\n      source: { root: 'src1' },\n      dest: sources\n    });\n    copy({\n      source: { root: 'src2' },\n      dest: sources\n    });\n    copy({\n      source: sources,\n      dest: 'sources-uncompressed.js'\n    });\n    copy({\n      source: sources,\n      filter: copy.filter.uglifyjs,\n      dest: 'sources.js'\n    });\n\nData objects are just JS objects with a 'value' member, so you can do all sorts\nof things with them:\n\n    var test = copy.createDataObject();\n    copy({\n      source: 'README.txt',\n      dest: test\n    });\n    console.log(test.value);\n\nOr:\n\n    copy({\n      source: { value: 'Hello, World!' },\n      dest: 'basic.txt'\n    });\n\nAnd you can mix and match your inputs:\n\n    copy({\n      source: [\n        'somefile.txt',\n        thingDataObject,\n        { root: 'src', include: /.*\\.js$/ },\n        function() { return 'wibble.sh'; }\n      ],\n      dest: 'mess.bin'\n    });\n\nCommon JS project dependency tracking:\n\n    var project = copy.createCommonJsProject({\n        roots: [\n            '/path/to/source/tree/lib',\n            '/some/other/project/lib'\n        ]\n    });\n    copy({\n        source: copy.source.commonjs({\n            project: project,\n            require: [ 'main', 'plugin/main' ]\n        }),\n        dest: ''\n    });\n\nThis digs around in the project source trees specified in the project for\nmodules named in the 'require' statement. When it finds them it looks through\nthem for require statements, and finds those, and so on.\n\n\nFormal Parameter Description\n----------------------------\n\nThe copy function takes a single parameter which is an object with 2 or 3\nmembers: `source`, `dest` and optionally `filter`.\n\n### source\n\nThere are 6 ways to specify the input source(s)\n\n* A *string* is expected to point to a filename.\n  At some stage we may allow them to point at directories too, however this\n  can be achieved today using a find object (see below)\n\n* A *find object* points to a directory with 2 optional RegExps specifying what\n  to exclude and include. e.g.\n\n    { root: '/' }                       -> The entire filesystem\n    { root: 'src', include: /.*\\.js$/ } -> All the JavaScript files in 'src'\n    { root: 'src', exclude: /test/ }    -> All non-test files under 'src'\n\n* A *data object* - something with a 'value' property.\n  The implementation of `copy.createDataObject()` is simply\n  `return { value: '' };`. We've batted around some ideas which involve making\n  `copy.createDataObject()` smarter than it currently is, so it is advised to\n  use this method rather than doing it yourself.\n\n* A *based object*. A based object is one with `base` and `path` members. They\n  are roughly the same as the string baseObj.base + baseObj.path. Based objects\n  are important when using CommonJS filters, because it tells the filter where\n  the root of the hierarchy is, which lets us know the module name.\n  For example:\n\n    { base: '/etc', path:PATH } where BASE+PATH = filename\n\n* An *array* containing input source entries. The array does not have to be\n  homogeneous.\n\n* A *function* which returns any input source entries.\n\n### filter\n\nThe filter member is optional. If it exists, it should contain either a function\nor an array of functions. The function should have the following signature:\n\n    function filter(value, location) {\n      ..\n      return 'some string';\n    }\n\nWhere the parameters are as follows:\n\n* value. Either a string or a node Buffer. Most filters will work only with\n  strings, so they should begin:\n\n      if (typeof value !== 'string') {\n          value = value.toString();\n      }\n\n  Some filters will only work with Buffers (for example the base64 encoding\n  filter) so they should begin:\n\n      if (typeof value === 'string') {\n          throw new Error('base64 filter needs to be the first in a filter set');\n      }\n\n  At some stage we may allow filters to be marked up as to their requirements.\n\n* location. This will be (where possible) a based object or it could be a\n  string if a based object is not available. It will be common to use one of the\n  following idioms to work on a filename:\n\n      if (location.base) {\n          location = location.path;\n      }\n\n  or\n\n      if (location.base) {\n          location = location.base + location.path;\n      }\n\nThere are 2 points in a copy run where filters could be used, either before the\nindividual sources are concatenated, or after. Some filters should be used in\nbefore (like common-js munging filters) and some afterwards (like compressors).\n\nThe default is to run filters after concatenation (when the location parameter\nwill be undefined). To run filters before concatenation, the filter should be\nmarked with `onRead = true`. For example:\n\n    function makeBlank(value, location) {\n      return '';\n    }\n    makeBlank.onRead = true;\n\nDryIce currently comes with 4 filters:\n\n* _copy.filter.uglifyjs_: Calls uglify on the input.\n* _copy.filter.addDefines_: Wraps the input to inline files fetched using\n  RequireJSs text import feature.\n* _copy.filter.base64_: Similar to addDefines, but assumes the input is\n  binary and should be base64 encoded.\n* _copy.filter.moduleDefines_: Replaces define lines to include the module name\n  e.g. `define(function(export, require, module) { ... });` is turned into\n  `define('module/name', function(export, require, module) { ... });`\n\n\n### dest\n\nThe dest property should be either a filename to which the output should be\nwritten (existing files will be over-written without warning), or a data object\nto which the data should be appended.\n\nCommonJS Projects\n-----------------\n\nCommonJS projects take a single object with the following properties:\n\n* `roots`: This is required. An array of directories that should be searched for\n  your required modules and dependencies.\n\n* `ignores`: This is optional. An array of modules or dependencies that are\n  required by your project that you would not like to be included in the\n  build. For example, if you were making a build which did not need to support\n  IE, you could do something like the following\n\n        copy.createCommonJsProject({\n            roots: [ '/path/to/project' ],\n            ignores: [ 'dom/ie-compat', 'event/ie-compat' ]\n        });\n\n  then wherever you had `require('dom/ie-compat')` or\n  `require('event/ie-compat')` inside your build, `undefined` would be returned\n  by `require`.\n\nWhere (is the project going)?\n-----------------------------\n\nDryIce is useful in combining scripts for the browser, but it could also be\nused in a similar role on the server, we just need to enable 'pass through\nrequires'.\n\nThere are some tweaks we'd still like to make to enable more filters and\nmultiple destinations:\n\nTo recursively copy a directory:\n\n    copy({ source: 'foo', destDir: 'bar' });\n\nTo rename files as we copy them:\n\n    copy({\n      source: { root:'src', include:/.*\\.png$/ },\n      destDir: { root:'built', replace:/png$/, with:'png.bak' }\n    });\n\nTo create a tarball (this is only missing the targz filter):\n\n    var version = copy.createDataObject();\n    copy({ source: 'VERSION.txt', dest: version });\n    copy({\n      source: { root:'.' },\n      filter: [ targz ],\n      dest: 'scp://example.com/upload/myproject-' + version + '.tar.gz'\n    });\n\nI don't suppose you would ever actually want to do this, but in theory you\ncould even do this:\n\n    copy({\n      source: { root:'src', include:/.*\\.java$/ },\n      filter: javac,\n      destDir: { root:'classes', replace:/java$/, with:'class' }\n    });\n\n(Actually there would be issues with ordering that would make this hard, and\nAnt/Maven/etc is probably better. This is an illustration dammit!)\n",
  "readmeFilename": "README.md",
  "_id": "dryice@0.4.10",
  "dist": {
    "shasum": "f90e20ddb899d087e32183ceba2941634dd47b25"
  },
  "_from": "dryice@0.4.10",
  "_resolved": "https://registry.npmjs.org/dryice/-/dryice-0.4.10.tgz"
}
